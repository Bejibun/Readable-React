{"version":3,"file":"formik.umd.min.js","sources":["../node_modules/tslib/tslib.es6.js","../src/utils.ts","../src/hoistStatics.tsx","../src/formik.tsx"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}","/** @private is the given object/value a promise? */\nexport function isPromise(value: any): boolean {\n  if (value !== null && typeof value === 'object') {\n    return value && typeof value.then === 'function';\n  }\n\n  return false;\n}\n\n/** @private is running React Native?  */\nexport const isReactNative =\n  typeof window !== 'undefined' &&\n  window.navigator &&\n  window.navigator.product &&\n  window.navigator.product === 'ReactNative';\n\n/** @private Returns values of an object in a new array */\nexport function values<T>(obj: any): T[] {\n  const vals = [];\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      vals.push(obj[key]);\n    }\n  }\n  return vals;\n}\n\n/** @private is the given object a Function? */\nexport const isFunction = (obj: any) => 'function' === typeof obj;\n","import { ComponentClass } from 'react';\n\nconst REACT_STATICS: any = {\n  childContextTypes: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true,\n};\n\nconst KNOWN_STATICS: any = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true,\n};\n\nconst getOwnPropertySymbols = Object.getOwnPropertySymbols;\nconst propIsEnumerable = Object.prototype.propertyIsEnumerable;\nconst getPrototypeOf = Object.getPrototypeOf;\nconst objectPrototype = getPrototypeOf && getPrototypeOf(Object);\nconst getOwnPropertyNames = Object.getOwnPropertyNames;\n\nexport function hoistNonReactStatics<P>(\n  targetComponent: ComponentClass<P>,\n  sourceComponent: ComponentClass<any>,\n  blacklist?: { [name: string]: boolean }\n): ComponentClass<P> {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n\n    if (objectPrototype) {\n      let inheritedComponent = getPrototypeOf(sourceComponent);\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n\n    let keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent) as any);\n    }\n\n    for (let i = 0; i < keys.length; ++i) {\n      let key: string = keys[i];\n      if (\n        !REACT_STATICS[key] &&\n        !KNOWN_STATICS[key] &&\n        (!blacklist || !blacklist[key])\n      ) {\n        // Only hoist enumerables and non-enumerable functions\n        if (\n          propIsEnumerable.call(sourceComponent, key) ||\n          typeof (sourceComponent as any)[key] === 'function'\n        ) {\n          try {\n            // Avoid failures from read-only properties\n            (targetComponent as any)[key] = (sourceComponent as any)[key];\n            // tslint:disable-next-line:no-empty\n          } catch (e) {}\n        }\n      }\n    }\n\n    return targetComponent;\n  }\n\n  return targetComponent;\n}\n","import * as React from 'react';\n\nimport { isFunction, isPromise, isReactNative, values } from './utils';\n\nimport { hoistNonReactStatics } from './hoistStatics';\n\n/**\n * Values of fields in the form\n */\nexport interface FormikValues {\n  [field: string]: any;\n}\n\n/**\n * An object containing error messages whose keys correspond to FormikValues.\n */\nexport type FormikErrors<Values extends FormikValues> = {\n  [Key in keyof Values]?: string\n};\n\n/**\n * An object containing touched state of the form whose keys correspond to FormikValues.\n */\nexport type FormikTouched<Values extends FormikValues> = {\n  [Key in keyof Values]?: boolean\n};\n\n/**\n * Formik configuration options\n */\nexport interface FormikConfig<\n  Props,\n  Values extends FormikValues,\n  DeprecatedPayload = Values\n  // tslint:disable-next-line:one-line\n> {\n  displayName?: string;\n  /** Map props to the form values */\n  mapPropsToValues?: (props: Props) => Values;\n  /** \n   * Map form values to submission payload \n   * @deprecated since 0.8.0\n   */\n  mapValuesToPayload?: (values: Values) => DeprecatedPayload;\n  /** \n   * Validation function. Must return an error object or promise that \n   * throws an error object where that object keys map to corresponding value.\n   */\n  validate?: (\n    values: Values,\n    props: Props\n  ) => void | FormikErrors<Values> | Promise<any>;\n  /** A Yup Schema */\n  validationSchema?: ((props: Props) => any) | any;\n  /** Submission handler */\n  handleSubmit: (\n    values: Values | DeprecatedPayload,\n    formikBag: FormikBag<Props, Values>\n  ) => void;\n  /** Tells Formik to validate the form on each input's onChange event */\n  validateOnChange?: boolean;\n  /** Tells Formik to validate the form on each input's onBlur event */\n  validateOnBlur?: boolean;\n  /** Tell Formik if initial form values are valid or not on first render */\n  isInitialValid?: boolean | ((props: Props) => boolean | undefined);\n}\n\n/**\n * Formik state tree\n */\nexport interface FormikState<Values> {\n  /** Form values */\n  values: Values;\n  /** \n   * Top level error, in case you need it \n   * @deprecated since 0.8.0\n   */\n  error?: any;\n  /** map of field names to specific error for that field */\n  errors: FormikErrors<Values>;\n  /** map of field names to whether the field has been touched */\n  touched: FormikTouched<Values>;\n  /** whether the form is currently submitting */\n  isSubmitting: boolean;\n  /** Top level status state, in case you need it */\n  status?: any;\n}\n\n/**\n * Formik computed properties. These are read-only.\n */\nexport interface FormikComputedProps {\n  /** True if any input has been touched. False otherwise. */\n  readonly dirty: boolean;\n  /** Result of isInitiallyValid on mount, then whether true values pass validation. */\n  readonly isValid: boolean;\n}\n\n/**\n * Formik state helpers\n */\nexport interface FormikActions<Props, Values> {\n  /** Manually set top level status. */\n  setStatus: (status?: any) => void;\n  /** \n   * Manually set top level error \n   * @deprecated since 0.8.0\n   */\n  setError: (e: any) => void;\n  /** Manually set errors object */\n  setErrors: (errors: FormikErrors<Values>) => void;\n  /** Manually set isSubmitting */\n  setSubmitting: (isSubmitting: boolean) => void;\n  /** Manually set touched object */\n  setTouched: (touched: FormikTouched<Values>) => void;\n  /** Manually set values object  */\n  setValues: (values: Values) => void;\n  /** Set value of form field directly */\n  setFieldValue: (field: keyof Values, value: any) => void;\n  /** Set error message of a form field directly */\n  setFieldError: (field: keyof Values, message: string) => void;\n  /** Set whether field has been touched directly */\n  setFieldTouched: (field: keyof Values, isTouched?: boolean) => void;\n  /** Reset form */\n  resetForm: (nextProps?: Props) => void;\n  /** Submit the form imperatively */\n  submitForm: () => void;\n}\n\n/**\n * Formik form event handlers \n */\nexport interface FormikHandlers {\n  /** Form submit handler */\n  handleSubmit: (e: React.FormEvent<HTMLFormElement>) => void;\n  /** Classic React change handler, keyed by input name */\n  handleChange: (e: React.ChangeEvent<any>) => void;\n  /** Mark input as touched */\n  handleBlur: (e: any) => void;\n  /** Change value of form field directly */\n  handleChangeValue: (name: string, value: any) => void;\n  /** Reset form event handler  */\n  handleReset: () => void;\n}\n\n/**\n * State, handlers, and helpers injected as props into the wrapped form component.\n */\nexport type InjectedFormikProps<Props, Values> = Props &\n  FormikState<Values> &\n  FormikActions<Props, Values> &\n  FormikHandlers &\n  FormikComputedProps;\n\n/**\n * Formik actions + { props }\n */\nexport type FormikBag<P, V> = { props: P } & FormikActions<P, V>;\n\nexport type CompositeComponent<P> =\n  | React.ComponentClass<P>\n  | React.StatelessComponent<P>;\n\nexport interface ComponentDecorator<TOwnProps, TMergedProps> {\n  (component: CompositeComponent<TMergedProps>): React.ComponentClass<\n    TOwnProps\n  >;\n}\n\nexport interface InferableComponentDecorator<TOwnProps> {\n  <T extends CompositeComponent<TOwnProps>>(component: T): T;\n}\n\nexport function Formik<Props, Values extends FormikValues, Payload = Values>({\n  displayName,\n  mapPropsToValues = vanillaProps => {\n    let values: Values = {} as Values;\n    for (let k in vanillaProps) {\n      if (\n        vanillaProps.hasOwnProperty(k) &&\n        typeof vanillaProps[k] !== 'function'\n      ) {\n        values[k] = vanillaProps[k];\n      }\n    }\n    return values;\n  },\n  mapValuesToPayload,\n  validate,\n  validationSchema,\n  handleSubmit,\n  validateOnChange = false,\n  validateOnBlur = true,\n  isInitialValid = false,\n}: FormikConfig<Props, Values, Payload>): ComponentDecorator<\n  Props,\n  InjectedFormikProps<Props, Values>\n> {\n  return function wrapWithFormik(\n    WrappedComponent: CompositeComponent<InjectedFormikProps<Props, Values>>\n  ) {\n    class Formik extends React.Component<Props, FormikState<Values>> {\n      public static displayName = `Formik(${displayName ||\n        WrappedComponent.displayName ||\n        WrappedComponent.name ||\n        'Component'})`;\n      public static WrappedComponent = WrappedComponent;\n      public props: Props;\n\n      constructor(props: Props) {\n        super(props);\n        this.state = {\n          values: mapPropsToValues(props),\n          errors: {},\n          touched: {},\n          isSubmitting: false,\n        };\n\n        if (mapValuesToPayload) {\n          console.warn(\n            `Warning: Formik\\'s mapValuesToPayload is deprecated and may be removed in future releases. Move that function to the first line of \\`handleSubmit\\` instead.`\n          );\n        }\n      }\n\n      setErrors = (errors: FormikErrors<Values>) => {\n        this.setState({ errors });\n      };\n\n      setTouched = (touched: FormikTouched<Values>) => {\n        this.setState({ touched });\n        if (validateOnBlur) {\n          this.runValidations(this.state.values);\n        }\n      };\n\n      setValues = (values: Values) => {\n        this.setState({ values });\n        if (validateOnChange) {\n          this.runValidations(values);\n        }\n      };\n\n      setStatus = (status?: any) => {\n        this.setState({ status });\n      };\n\n      setError = (error: any) => {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Warning: Formik\\'s setError(error) is deprecated and may be removed in future releases. Please use Formik\\'s setStatus(status) instead. It works identically. For more info see https://github.com/jaredpalmer/formik#setstatus-status-any--void`\n          );\n        }\n        this.setState({ error });\n      };\n\n      setSubmitting = (isSubmitting: boolean) => {\n        this.setState({ isSubmitting });\n      };\n\n      /**\n       * Run validation against a Yup schema and optionally run a function if successful\n       */\n      runValidationSchema = (values: Values, onSuccess?: Function) => {\n        const schema = isFunction(validationSchema)\n          ? validationSchema(this.props)\n          : validationSchema;\n        validateYupSchema<Values>(values, schema).then(\n          () => {\n            this.setState({ errors: {} });\n            if (onSuccess) {\n              onSuccess();\n            }\n          },\n          (err: any) =>\n            this.setState({ errors: yupToFormErrors(err), isSubmitting: false })\n        );\n      };\n\n      /**\n       * Run validations and update state accordingly\n       */\n      runValidations = (values: Values) => {\n        if (validationSchema) {\n          this.runValidationSchema(values);\n        }\n\n        if (validate) {\n          const maybePromisedErrors = validate(values, this.props);\n          if (isPromise(maybePromisedErrors)) {\n            (maybePromisedErrors as Promise<any>).then(\n              () => {\n                this.setState({ errors: {} });\n              },\n              errors => this.setState({ errors, isSubmitting: false })\n            );\n          } else {\n            this.setErrors(maybePromisedErrors as FormikErrors<Values>);\n          }\n        }\n      };\n\n      handleChange = (e: React.ChangeEvent<any>) => {\n        if (isReactNative) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Warning: Formik's handleChange does not work with React Native. Use setFieldValue and within a callback instead. For more info see https://github.com/jaredpalmer/formikhttps://github.com/jaredpalmer/formik#react-native`\n            );\n          }\n          return;\n        }\n        e.persist();\n        const { type, name, id, value, checked, outerHTML } = e.target;\n        const field = name ? name : id;\n        const val = /number|range/.test(type)\n          ? parseFloat(value)\n          : /checkbox/.test(type) ? checked : value;\n\n        if (!field && process.env.NODE_ENV !== 'production') {\n          console.error(\n            `Warning: You forgot to pass an \\`id\\` or \\`name\\` attribute to your input:\n\n  ${outerHTML}\n\nFormik cannot determine which value to update. For more info see https://github.com/jaredpalmer/formik#handlechange-e-reactchangeeventany--void\n`\n          );\n        }\n\n        // Set form fields by name\n        this.setState(prevState => ({\n          ...prevState,\n          values: {\n            ...prevState.values as object,\n            [field]: val,\n          },\n        }));\n\n        if (validateOnChange) {\n          this.runValidations(\n            {\n              ...this.state.values as object,\n              [field]: value,\n            } as Values\n          );\n        }\n      };\n\n      handleChangeValue = (field: string, value: any) => {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Warning: Formik\\'s handleChangeValue is deprecated and may be removed in future releases. Use Formik's setFieldValue(field, value) and setFieldTouched(field, isTouched) instead. React will merge the updates under the hood and avoid a double render. For more info see https://github.com/jaredpalmer/formik#setfieldvalue-field-string-value-any--void`\n          );\n        }\n        // Set touched and form fields by name\n        this.setState(prevState => ({\n          ...prevState,\n          values: {\n            ...prevState.values as object,\n            [field]: value,\n          },\n          touched: {\n            ...prevState.touched as object,\n            [field]: true,\n          },\n        }));\n\n        this.runValidationSchema(\n          {\n            ...this.state.values as object,\n            [field]: value,\n          } as Values\n        );\n      };\n\n      setFieldValue = (field: keyof Values, value: any) => {\n        // Set form field by name\n        this.setState(prevState => ({\n          ...prevState,\n          values: {\n            ...prevState.values as object,\n            [field]: value,\n          },\n        }));\n\n        if (validateOnChange) {\n          this.runValidations(\n            {\n              ...this.state.values as object,\n              [field]: value,\n            } as Values\n          );\n        }\n      };\n\n      handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n        e.preventDefault();\n        this.submitForm();\n      };\n\n      submitForm = () => {\n        this.setState({\n          touched: touchAllFields<FormikTouched<Values>>(this.state.values),\n          isSubmitting: true,\n        });\n\n        if (validate) {\n          const maybePromisedErrors =\n            validate(this.state.values, this.props) || {};\n          if (isPromise(maybePromisedErrors)) {\n            (maybePromisedErrors as Promise<any>).then(\n              () => {\n                this.setState({ errors: {} });\n                this.executeSubmit();\n              },\n              errors => this.setState({ errors, isSubmitting: false })\n            );\n            return;\n          } else {\n            const isValid = Object.keys(maybePromisedErrors).length === 0;\n            this.setState({\n              errors: maybePromisedErrors as FormikErrors<Values>,\n              isSubmitting: isValid,\n            });\n\n            // only submit if there are no errors\n            if (isValid) {\n              this.executeSubmit();\n            }\n          }\n        } else if (validationSchema) {\n          this.runValidationSchema(this.state.values, this.executeSubmit);\n        } else {\n          this.executeSubmit();\n        }\n      };\n\n      executeSubmit = () => {\n        const values = mapValuesToPayload\n          ? mapValuesToPayload(this.state.values)\n          : this.state.values;\n        handleSubmit(values, {\n          setStatus: this.setStatus,\n          setTouched: this.setTouched,\n          setErrors: this.setErrors,\n          setError: this.setError,\n          setValues: this.setValues,\n          setFieldError: this.setFieldError,\n          setFieldValue: this.setFieldValue,\n          setFieldTouched: this.setFieldTouched,\n          setSubmitting: this.setSubmitting,\n          resetForm: this.resetForm,\n          submitForm: this.submitForm,\n          props: this.props,\n        });\n      };\n\n      handleBlur = (e: any) => {\n        if (isReactNative) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Warning: Formik's handleBlur does not work with React Native. Use setFieldTouched(field, isTouched) within a callback instead. For more info see https://github.com/jaredpalmer/formik#setfieldtouched-field-string-istouched-boolean--void`\n            );\n          }\n          return;\n        }\n        e.persist();\n        const { name, id } = e.target;\n        const field = name ? name : id;\n        this.setState(prevState => ({\n          touched: { ...prevState.touched as object, [field]: true },\n        }));\n\n        if (validateOnBlur) {\n          this.runValidations(this.state.values);\n        }\n      };\n\n      setFieldTouched = (field: keyof Values, touched: boolean = true) => {\n        // Set touched field by name\n        this.setState(prevState => ({\n          ...prevState,\n          touched: {\n            ...prevState.touched as object,\n            [field]: touched,\n          },\n        }));\n\n        if (validateOnBlur) {\n          this.runValidations(this.state.values);\n        }\n      };\n\n      setFieldError = (field: keyof Values, message: string) => {\n        // Set form field by name\n        this.setState(prevState => ({\n          ...prevState,\n          errors: {\n            ...prevState.errors as object,\n            [field]: message,\n          },\n        }));\n      };\n\n      resetForm = (nextProps?: Props) => {\n        this.setState({\n          isSubmitting: false,\n          errors: {},\n          touched: {},\n          error: undefined,\n          status: undefined,\n          values: nextProps\n            ? mapPropsToValues(nextProps)\n            : mapPropsToValues(this.props),\n        });\n      };\n\n      handleReset = () => {\n        this.setState({\n          isSubmitting: false,\n          errors: {},\n          touched: {},\n          error: undefined,\n          status: undefined,\n          values: mapPropsToValues(this.props),\n        });\n      };\n\n      render() {\n        const dirty =\n          values<boolean>(this.state.touched).filter(Boolean).length > 0;\n        return (\n          <WrappedComponent\n            {...this.props}\n            {...this.state}\n            dirty={dirty}\n            isValid={\n              dirty\n                ? this.state.errors &&\n                  Object.keys(this.state.errors).length === 0\n                : isInitialValid !== false && isFunction(isInitialValid)\n                  ? (isInitialValid as (props: Props) => boolean)(this.props)\n                  : isInitialValid as boolean\n            }\n            setStatus={this.setStatus}\n            setError={this.setError}\n            setFieldError={this.setFieldError}\n            setErrors={this.setErrors}\n            setSubmitting={this.setSubmitting}\n            setTouched={this.setTouched}\n            setFieldTouched={this.setFieldTouched}\n            setValues={this.setValues}\n            setFieldValue={this.setFieldValue}\n            resetForm={this.resetForm}\n            submitForm={this.submitForm}\n            handleReset={this.handleReset}\n            handleSubmit={this.handleSubmit}\n            handleChange={this.handleChange}\n            handleBlur={this.handleBlur}\n            handleChangeValue={this.handleChangeValue}\n          />\n        );\n      }\n    }\n    return hoistNonReactStatics<Props>(\n      Formik,\n      WrappedComponent as React.ComponentClass<\n        InjectedFormikProps<Props, Values>\n      > // cast type to ComponentClass (even if SFC)\n    ) as React.ComponentClass<Props>;\n  };\n}\n\n/**\n * Transform Yup ValidationError to a more usable object\n */\nexport function yupToFormErrors<Values>(yupError: any): FormikErrors<Values> {\n  let errors: FormikErrors<Values> = {};\n  for (let err of yupError.inner) {\n    if (!errors[err.path]) {\n      errors[err.path] = err.message;\n    }\n  }\n  return errors;\n}\n\n/**\n * Validate a yup schema.\n */\nexport function validateYupSchema<T>(data: T, schema: any): Promise<void> {\n  let validateData: any = {};\n  for (let k in data) {\n    if (data.hasOwnProperty(k)) {\n      const key = String(k);\n      validateData[key] =\n        (data as any)[key] !== '' ? (data as any)[key] : undefined;\n    }\n  }\n  return schema.validate(validateData, { abortEarly: false });\n}\n\nexport function touchAllFields<T>(fields: T): FormikTouched<T> {\n  let touched = {} as FormikTouched<T>;\n  for (let k of Object.keys(fields)) {\n    touched[k] = true;\n  }\n  return touched;\n}\n"],"names":["__extends","d","b","__","this","constructor","extendStatics","prototype","Object","create","value","then","obj","vals","key","hasOwnProperty","push","targetComponent","sourceComponent","blacklist","objectPrototype","inheritedComponent","getPrototypeOf","hoistNonReactStatics","keys","getOwnPropertyNames","getOwnPropertySymbols","concat","i","length","REACT_STATICS","KNOWN_STATICS","propIsEnumerable","call","e","yupError","errors","_a","inner","_i","err","path","message","data","schema","validateData","k","String","undefined","validate","abortEarly","fields","touched","setPrototypeOf","__proto__","Array","p","__assign","assign","t","s","n","arguments","isReactNative","window","navigator","product","isFunction","childContextTypes","contextTypes","defaultProps","displayName","getDefaultProps","mixins","propTypes","type","name","caller","callee","arity","propertyIsEnumerable","_b","mapPropsToValues","mapValuesToPayload","validationSchema","handleSubmit","_c","validateOnChange","_d","validateOnBlur","_e","isInitialValid","WrappedComponent","props","_super","_this","setState","runValidations","state","values","status","error","isSubmitting","onSuccess","validateYupSchema","yupToFormErrors","runValidationSchema","maybePromisedErrors","isPromise","setErrors","persist","id","checked","field","val","test","parseFloat","prevState","tslib_1.__assign","preventDefault","submitForm","touchAllFields","executeSubmit","isValid","setStatus","setTouched","setError","setValues","setFieldError","setFieldValue","setFieldTouched","setSubmitting","resetForm","nextProps","console","warn","tslib_1.__extends","Formik","dirty","filter","Boolean","React.createElement","handleReset","handleChange","handleBlur","handleChangeValue","React.Component"],"mappings":"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"}