{"version":3,"file":"formik.js","sources":["../node_modules/tslib/tslib.es6.js","../src/utils.ts","../src/hoistStatics.tsx","../src/formik.tsx"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}","/** @private is the given object/value a promise? */\nexport function isPromise(value: any): boolean {\n  if (value !== null && typeof value === 'object') {\n    return value && typeof value.then === 'function';\n  }\n\n  return false;\n}\n\n/** @private is running React Native?  */\nexport const isReactNative =\n  typeof window !== 'undefined' &&\n  window.navigator &&\n  window.navigator.product &&\n  window.navigator.product === 'ReactNative';\n\n/** @private Returns values of an object in a new array */\nexport function values<T>(obj: any): T[] {\n  const vals = [];\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      vals.push(obj[key]);\n    }\n  }\n  return vals;\n}\n\n/** @private is the given object a Function? */\nexport const isFunction = (obj: any) => 'function' === typeof obj;\n","import { ComponentClass } from 'react';\n\nconst REACT_STATICS: any = {\n  childContextTypes: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true,\n};\n\nconst KNOWN_STATICS: any = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true,\n};\n\nconst getOwnPropertySymbols = Object.getOwnPropertySymbols;\nconst propIsEnumerable = Object.prototype.propertyIsEnumerable;\nconst getPrototypeOf = Object.getPrototypeOf;\nconst objectPrototype = getPrototypeOf && getPrototypeOf(Object);\nconst getOwnPropertyNames = Object.getOwnPropertyNames;\n\nexport function hoistNonReactStatics<P>(\n  targetComponent: ComponentClass<P>,\n  sourceComponent: ComponentClass<any>,\n  blacklist?: { [name: string]: boolean }\n): ComponentClass<P> {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n\n    if (objectPrototype) {\n      let inheritedComponent = getPrototypeOf(sourceComponent);\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n\n    let keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent) as any);\n    }\n\n    for (let i = 0; i < keys.length; ++i) {\n      let key: string = keys[i];\n      if (\n        !REACT_STATICS[key] &&\n        !KNOWN_STATICS[key] &&\n        (!blacklist || !blacklist[key])\n      ) {\n        // Only hoist enumerables and non-enumerable functions\n        if (\n          propIsEnumerable.call(sourceComponent, key) ||\n          typeof (sourceComponent as any)[key] === 'function'\n        ) {\n          try {\n            // Avoid failures from read-only properties\n            (targetComponent as any)[key] = (sourceComponent as any)[key];\n            // tslint:disable-next-line:no-empty\n          } catch (e) {}\n        }\n      }\n    }\n\n    return targetComponent;\n  }\n\n  return targetComponent;\n}\n","import * as React from 'react';\n\nimport { isFunction, isPromise, isReactNative, values } from './utils';\n\nimport { hoistNonReactStatics } from './hoistStatics';\n\n/**\n * Values of fields in the form\n */\nexport interface FormikValues {\n  [field: string]: any;\n}\n\n/**\n * An object containing error messages whose keys correspond to FormikValues.\n */\nexport type FormikErrors<Values extends FormikValues> = {\n  [Key in keyof Values]?: string\n};\n\n/**\n * An object containing touched state of the form whose keys correspond to FormikValues.\n */\nexport type FormikTouched<Values extends FormikValues> = {\n  [Key in keyof Values]?: boolean\n};\n\n/**\n * Formik configuration options\n */\nexport interface FormikConfig<\n  Props,\n  Values extends FormikValues,\n  DeprecatedPayload = Values\n  // tslint:disable-next-line:one-line\n> {\n  displayName?: string;\n  /** Map props to the form values */\n  mapPropsToValues?: (props: Props) => Values;\n  /** \n   * Map form values to submission payload \n   * @deprecated since 0.8.0\n   */\n  mapValuesToPayload?: (values: Values) => DeprecatedPayload;\n  /** \n   * Validation function. Must return an error object or promise that \n   * throws an error object where that object keys map to corresponding value.\n   */\n  validate?: (\n    values: Values,\n    props: Props\n  ) => void | FormikErrors<Values> | Promise<any>;\n  /** A Yup Schema */\n  validationSchema?: ((props: Props) => any) | any;\n  /** Submission handler */\n  handleSubmit: (\n    values: Values | DeprecatedPayload,\n    formikBag: FormikBag<Props, Values>\n  ) => void;\n  /** Tells Formik to validate the form on each input's onChange event */\n  validateOnChange?: boolean;\n  /** Tells Formik to validate the form on each input's onBlur event */\n  validateOnBlur?: boolean;\n  /** Tell Formik if initial form values are valid or not on first render */\n  isInitialValid?: boolean | ((props: Props) => boolean | undefined);\n}\n\n/**\n * Formik state tree\n */\nexport interface FormikState<Values> {\n  /** Form values */\n  values: Values;\n  /** \n   * Top level error, in case you need it \n   * @deprecated since 0.8.0\n   */\n  error?: any;\n  /** map of field names to specific error for that field */\n  errors: FormikErrors<Values>;\n  /** map of field names to whether the field has been touched */\n  touched: FormikTouched<Values>;\n  /** whether the form is currently submitting */\n  isSubmitting: boolean;\n  /** Top level status state, in case you need it */\n  status?: any;\n}\n\n/**\n * Formik computed properties. These are read-only.\n */\nexport interface FormikComputedProps {\n  /** True if any input has been touched. False otherwise. */\n  readonly dirty: boolean;\n  /** Result of isInitiallyValid on mount, then whether true values pass validation. */\n  readonly isValid: boolean;\n}\n\n/**\n * Formik state helpers\n */\nexport interface FormikActions<Props, Values> {\n  /** Manually set top level status. */\n  setStatus: (status?: any) => void;\n  /** \n   * Manually set top level error \n   * @deprecated since 0.8.0\n   */\n  setError: (e: any) => void;\n  /** Manually set errors object */\n  setErrors: (errors: FormikErrors<Values>) => void;\n  /** Manually set isSubmitting */\n  setSubmitting: (isSubmitting: boolean) => void;\n  /** Manually set touched object */\n  setTouched: (touched: FormikTouched<Values>) => void;\n  /** Manually set values object  */\n  setValues: (values: Values) => void;\n  /** Set value of form field directly */\n  setFieldValue: (field: keyof Values, value: any) => void;\n  /** Set error message of a form field directly */\n  setFieldError: (field: keyof Values, message: string) => void;\n  /** Set whether field has been touched directly */\n  setFieldTouched: (field: keyof Values, isTouched?: boolean) => void;\n  /** Reset form */\n  resetForm: (nextProps?: Props) => void;\n  /** Submit the form imperatively */\n  submitForm: () => void;\n}\n\n/**\n * Formik form event handlers \n */\nexport interface FormikHandlers {\n  /** Form submit handler */\n  handleSubmit: (e: React.FormEvent<HTMLFormElement>) => void;\n  /** Classic React change handler, keyed by input name */\n  handleChange: (e: React.ChangeEvent<any>) => void;\n  /** Mark input as touched */\n  handleBlur: (e: any) => void;\n  /** Change value of form field directly */\n  handleChangeValue: (name: string, value: any) => void;\n  /** Reset form event handler  */\n  handleReset: () => void;\n}\n\n/**\n * State, handlers, and helpers injected as props into the wrapped form component.\n */\nexport type InjectedFormikProps<Props, Values> = Props &\n  FormikState<Values> &\n  FormikActions<Props, Values> &\n  FormikHandlers &\n  FormikComputedProps;\n\n/**\n * Formik actions + { props }\n */\nexport type FormikBag<P, V> = { props: P } & FormikActions<P, V>;\n\nexport type CompositeComponent<P> =\n  | React.ComponentClass<P>\n  | React.StatelessComponent<P>;\n\nexport interface ComponentDecorator<TOwnProps, TMergedProps> {\n  (component: CompositeComponent<TMergedProps>): React.ComponentClass<\n    TOwnProps\n  >;\n}\n\nexport interface InferableComponentDecorator<TOwnProps> {\n  <T extends CompositeComponent<TOwnProps>>(component: T): T;\n}\n\nexport function Formik<Props, Values extends FormikValues, Payload = Values>({\n  displayName,\n  mapPropsToValues = vanillaProps => {\n    let values: Values = {} as Values;\n    for (let k in vanillaProps) {\n      if (\n        vanillaProps.hasOwnProperty(k) &&\n        typeof vanillaProps[k] !== 'function'\n      ) {\n        values[k] = vanillaProps[k];\n      }\n    }\n    return values;\n  },\n  mapValuesToPayload,\n  validate,\n  validationSchema,\n  handleSubmit,\n  validateOnChange = false,\n  validateOnBlur = true,\n  isInitialValid = false,\n}: FormikConfig<Props, Values, Payload>): ComponentDecorator<\n  Props,\n  InjectedFormikProps<Props, Values>\n> {\n  return function wrapWithFormik(\n    WrappedComponent: CompositeComponent<InjectedFormikProps<Props, Values>>\n  ) {\n    class Formik extends React.Component<Props, FormikState<Values>> {\n      public static displayName = `Formik(${displayName ||\n        WrappedComponent.displayName ||\n        WrappedComponent.name ||\n        'Component'})`;\n      public static WrappedComponent = WrappedComponent;\n      public props: Props;\n\n      constructor(props: Props) {\n        super(props);\n        this.state = {\n          values: mapPropsToValues(props),\n          errors: {},\n          touched: {},\n          isSubmitting: false,\n        };\n\n        if (mapValuesToPayload) {\n          console.warn(\n            `Warning: Formik\\'s mapValuesToPayload is deprecated and may be removed in future releases. Move that function to the first line of \\`handleSubmit\\` instead.`\n          );\n        }\n      }\n\n      setErrors = (errors: FormikErrors<Values>) => {\n        this.setState({ errors });\n      };\n\n      setTouched = (touched: FormikTouched<Values>) => {\n        this.setState({ touched });\n        if (validateOnBlur) {\n          this.runValidations(this.state.values);\n        }\n      };\n\n      setValues = (values: Values) => {\n        this.setState({ values });\n        if (validateOnChange) {\n          this.runValidations(values);\n        }\n      };\n\n      setStatus = (status?: any) => {\n        this.setState({ status });\n      };\n\n      setError = (error: any) => {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Warning: Formik\\'s setError(error) is deprecated and may be removed in future releases. Please use Formik\\'s setStatus(status) instead. It works identically. For more info see https://github.com/jaredpalmer/formik#setstatus-status-any--void`\n          );\n        }\n        this.setState({ error });\n      };\n\n      setSubmitting = (isSubmitting: boolean) => {\n        this.setState({ isSubmitting });\n      };\n\n      /**\n       * Run validation against a Yup schema and optionally run a function if successful\n       */\n      runValidationSchema = (values: Values, onSuccess?: Function) => {\n        const schema = isFunction(validationSchema)\n          ? validationSchema(this.props)\n          : validationSchema;\n        validateYupSchema<Values>(values, schema).then(\n          () => {\n            this.setState({ errors: {} });\n            if (onSuccess) {\n              onSuccess();\n            }\n          },\n          (err: any) =>\n            this.setState({ errors: yupToFormErrors(err), isSubmitting: false })\n        );\n      };\n\n      /**\n       * Run validations and update state accordingly\n       */\n      runValidations = (values: Values) => {\n        if (validationSchema) {\n          this.runValidationSchema(values);\n        }\n\n        if (validate) {\n          const maybePromisedErrors = validate(values, this.props);\n          if (isPromise(maybePromisedErrors)) {\n            (maybePromisedErrors as Promise<any>).then(\n              () => {\n                this.setState({ errors: {} });\n              },\n              errors => this.setState({ errors, isSubmitting: false })\n            );\n          } else {\n            this.setErrors(maybePromisedErrors as FormikErrors<Values>);\n          }\n        }\n      };\n\n      handleChange = (e: React.ChangeEvent<any>) => {\n        if (isReactNative) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Warning: Formik's handleChange does not work with React Native. Use setFieldValue and within a callback instead. For more info see https://github.com/jaredpalmer/formikhttps://github.com/jaredpalmer/formik#react-native`\n            );\n          }\n          return;\n        }\n        e.persist();\n        const { type, name, id, value, checked, outerHTML } = e.target;\n        const field = name ? name : id;\n        const val = /number|range/.test(type)\n          ? parseFloat(value)\n          : /checkbox/.test(type) ? checked : value;\n\n        if (!field && process.env.NODE_ENV !== 'production') {\n          console.error(\n            `Warning: You forgot to pass an \\`id\\` or \\`name\\` attribute to your input:\n\n  ${outerHTML}\n\nFormik cannot determine which value to update. For more info see https://github.com/jaredpalmer/formik#handlechange-e-reactchangeeventany--void\n`\n          );\n        }\n\n        // Set form fields by name\n        this.setState(prevState => ({\n          ...prevState,\n          values: {\n            ...prevState.values as object,\n            [field]: val,\n          },\n        }));\n\n        if (validateOnChange) {\n          this.runValidations(\n            {\n              ...this.state.values as object,\n              [field]: value,\n            } as Values\n          );\n        }\n      };\n\n      handleChangeValue = (field: string, value: any) => {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Warning: Formik\\'s handleChangeValue is deprecated and may be removed in future releases. Use Formik's setFieldValue(field, value) and setFieldTouched(field, isTouched) instead. React will merge the updates under the hood and avoid a double render. For more info see https://github.com/jaredpalmer/formik#setfieldvalue-field-string-value-any--void`\n          );\n        }\n        // Set touched and form fields by name\n        this.setState(prevState => ({\n          ...prevState,\n          values: {\n            ...prevState.values as object,\n            [field]: value,\n          },\n          touched: {\n            ...prevState.touched as object,\n            [field]: true,\n          },\n        }));\n\n        this.runValidationSchema(\n          {\n            ...this.state.values as object,\n            [field]: value,\n          } as Values\n        );\n      };\n\n      setFieldValue = (field: keyof Values, value: any) => {\n        // Set form field by name\n        this.setState(prevState => ({\n          ...prevState,\n          values: {\n            ...prevState.values as object,\n            [field]: value,\n          },\n        }));\n\n        if (validateOnChange) {\n          this.runValidations(\n            {\n              ...this.state.values as object,\n              [field]: value,\n            } as Values\n          );\n        }\n      };\n\n      handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n        e.preventDefault();\n        this.submitForm();\n      };\n\n      submitForm = () => {\n        this.setState({\n          touched: touchAllFields<FormikTouched<Values>>(this.state.values),\n          isSubmitting: true,\n        });\n\n        if (validate) {\n          const maybePromisedErrors =\n            validate(this.state.values, this.props) || {};\n          if (isPromise(maybePromisedErrors)) {\n            (maybePromisedErrors as Promise<any>).then(\n              () => {\n                this.setState({ errors: {} });\n                this.executeSubmit();\n              },\n              errors => this.setState({ errors, isSubmitting: false })\n            );\n            return;\n          } else {\n            const isValid = Object.keys(maybePromisedErrors).length === 0;\n            this.setState({\n              errors: maybePromisedErrors as FormikErrors<Values>,\n              isSubmitting: isValid,\n            });\n\n            // only submit if there are no errors\n            if (isValid) {\n              this.executeSubmit();\n            }\n          }\n        } else if (validationSchema) {\n          this.runValidationSchema(this.state.values, this.executeSubmit);\n        } else {\n          this.executeSubmit();\n        }\n      };\n\n      executeSubmit = () => {\n        const values = mapValuesToPayload\n          ? mapValuesToPayload(this.state.values)\n          : this.state.values;\n        handleSubmit(values, {\n          setStatus: this.setStatus,\n          setTouched: this.setTouched,\n          setErrors: this.setErrors,\n          setError: this.setError,\n          setValues: this.setValues,\n          setFieldError: this.setFieldError,\n          setFieldValue: this.setFieldValue,\n          setFieldTouched: this.setFieldTouched,\n          setSubmitting: this.setSubmitting,\n          resetForm: this.resetForm,\n          submitForm: this.submitForm,\n          props: this.props,\n        });\n      };\n\n      handleBlur = (e: any) => {\n        if (isReactNative) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Warning: Formik's handleBlur does not work with React Native. Use setFieldTouched(field, isTouched) within a callback instead. For more info see https://github.com/jaredpalmer/formik#setfieldtouched-field-string-istouched-boolean--void`\n            );\n          }\n          return;\n        }\n        e.persist();\n        const { name, id } = e.target;\n        const field = name ? name : id;\n        this.setState(prevState => ({\n          touched: { ...prevState.touched as object, [field]: true },\n        }));\n\n        if (validateOnBlur) {\n          this.runValidations(this.state.values);\n        }\n      };\n\n      setFieldTouched = (field: keyof Values, touched: boolean = true) => {\n        // Set touched field by name\n        this.setState(prevState => ({\n          ...prevState,\n          touched: {\n            ...prevState.touched as object,\n            [field]: touched,\n          },\n        }));\n\n        if (validateOnBlur) {\n          this.runValidations(this.state.values);\n        }\n      };\n\n      setFieldError = (field: keyof Values, message: string) => {\n        // Set form field by name\n        this.setState(prevState => ({\n          ...prevState,\n          errors: {\n            ...prevState.errors as object,\n            [field]: message,\n          },\n        }));\n      };\n\n      resetForm = (nextProps?: Props) => {\n        this.setState({\n          isSubmitting: false,\n          errors: {},\n          touched: {},\n          error: undefined,\n          status: undefined,\n          values: nextProps\n            ? mapPropsToValues(nextProps)\n            : mapPropsToValues(this.props),\n        });\n      };\n\n      handleReset = () => {\n        this.setState({\n          isSubmitting: false,\n          errors: {},\n          touched: {},\n          error: undefined,\n          status: undefined,\n          values: mapPropsToValues(this.props),\n        });\n      };\n\n      render() {\n        const dirty =\n          values<boolean>(this.state.touched).filter(Boolean).length > 0;\n        return (\n          <WrappedComponent\n            {...this.props}\n            {...this.state}\n            dirty={dirty}\n            isValid={\n              dirty\n                ? this.state.errors &&\n                  Object.keys(this.state.errors).length === 0\n                : isInitialValid !== false && isFunction(isInitialValid)\n                  ? (isInitialValid as (props: Props) => boolean)(this.props)\n                  : isInitialValid as boolean\n            }\n            setStatus={this.setStatus}\n            setError={this.setError}\n            setFieldError={this.setFieldError}\n            setErrors={this.setErrors}\n            setSubmitting={this.setSubmitting}\n            setTouched={this.setTouched}\n            setFieldTouched={this.setFieldTouched}\n            setValues={this.setValues}\n            setFieldValue={this.setFieldValue}\n            resetForm={this.resetForm}\n            submitForm={this.submitForm}\n            handleReset={this.handleReset}\n            handleSubmit={this.handleSubmit}\n            handleChange={this.handleChange}\n            handleBlur={this.handleBlur}\n            handleChangeValue={this.handleChangeValue}\n          />\n        );\n      }\n    }\n    return hoistNonReactStatics<Props>(\n      Formik,\n      WrappedComponent as React.ComponentClass<\n        InjectedFormikProps<Props, Values>\n      > // cast type to ComponentClass (even if SFC)\n    ) as React.ComponentClass<Props>;\n  };\n}\n\n/**\n * Transform Yup ValidationError to a more usable object\n */\nexport function yupToFormErrors<Values>(yupError: any): FormikErrors<Values> {\n  let errors: FormikErrors<Values> = {};\n  for (let err of yupError.inner) {\n    if (!errors[err.path]) {\n      errors[err.path] = err.message;\n    }\n  }\n  return errors;\n}\n\n/**\n * Validate a yup schema.\n */\nexport function validateYupSchema<T>(data: T, schema: any): Promise<void> {\n  let validateData: any = {};\n  for (let k in data) {\n    if (data.hasOwnProperty(k)) {\n      const key = String(k);\n      validateData[key] =\n        (data as any)[key] !== '' ? (data as any)[key] : undefined;\n    }\n  }\n  return schema.validate(validateData, { abortEarly: false });\n}\n\nexport function touchAllFields<T>(fields: T): FormikTouched<T> {\n  let touched = {} as FormikTouched<T>;\n  for (let k of Object.keys(fields)) {\n    touched[k] = true;\n  }\n  return touched;\n}\n"],"names":["tslib_1.__extends","values","tslib_1.__assign","React.createElement","React.Component"],"mappings":"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"}