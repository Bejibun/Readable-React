'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};

function isPromise(value) {
    if (value !== null && typeof value === 'object') {
        return value && typeof value.then === 'function';
    }
    return false;
}
var isReactNative = typeof window !== 'undefined' &&
    window.navigator &&
    window.navigator.product &&
    window.navigator.product === 'ReactNative';
function values(obj) {
    var vals = [];
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            vals.push(obj[key]);
        }
    }
    return vals;
}
var isFunction = function (obj) { return 'function' === typeof obj; };

var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true,
};
var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true,
};
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);
var getOwnPropertyNames = Object.getOwnPropertyNames;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] &&
                !KNOWN_STATICS[key] &&
                (!blacklist || !blacklist[key])) {
                if (propIsEnumerable.call(sourceComponent, key) ||
                    typeof sourceComponent[key] === 'function') {
                    try {
                        targetComponent[key] = sourceComponent[key];
                    }
                    catch (e) { }
                }
            }
        }
        return targetComponent;
    }
    return targetComponent;
}

function Formik(_a) {
    var displayName = _a.displayName, _b = _a.mapPropsToValues, mapPropsToValues = _b === void 0 ? function (vanillaProps) {
        var values$$1 = {};
        for (var k in vanillaProps) {
            if (vanillaProps.hasOwnProperty(k) &&
                typeof vanillaProps[k] !== 'function') {
                values$$1[k] = vanillaProps[k];
            }
        }
        return values$$1;
    } : _b, mapValuesToPayload = _a.mapValuesToPayload, validate = _a.validate, validationSchema = _a.validationSchema, handleSubmit = _a.handleSubmit, _c = _a.validateOnChange, validateOnChange = _c === void 0 ? false : _c, _d = _a.validateOnBlur, validateOnBlur = _d === void 0 ? true : _d, _e = _a.isInitialValid, isInitialValid = _e === void 0 ? false : _e;
    return function wrapWithFormik(WrappedComponent) {
        var Formik = (function (_super) {
            __extends(Formik, _super);
            function Formik(props) {
                var _this = _super.call(this, props) || this;
                _this.setErrors = function (errors) {
                    _this.setState({ errors: errors });
                };
                _this.setTouched = function (touched) {
                    _this.setState({ touched: touched });
                    if (validateOnBlur) {
                        _this.runValidations(_this.state.values);
                    }
                };
                _this.setValues = function (values$$1) {
                    _this.setState({ values: values$$1 });
                    if (validateOnChange) {
                        _this.runValidations(values$$1);
                    }
                };
                _this.setStatus = function (status) {
                    _this.setState({ status: status });
                };
                _this.setError = function (error) {
                    if (process.env.NODE_ENV !== 'production') {
                        console.warn("Warning: Formik's setError(error) is deprecated and may be removed in future releases. Please use Formik's setStatus(status) instead. It works identically. For more info see https://github.com/jaredpalmer/formik#setstatus-status-any--void");
                    }
                    _this.setState({ error: error });
                };
                _this.setSubmitting = function (isSubmitting) {
                    _this.setState({ isSubmitting: isSubmitting });
                };
                _this.runValidationSchema = function (values$$1, onSuccess) {
                    var schema = isFunction(validationSchema)
                        ? validationSchema(_this.props)
                        : validationSchema;
                    validateYupSchema(values$$1, schema).then(function () {
                        _this.setState({ errors: {} });
                        if (onSuccess) {
                            onSuccess();
                        }
                    }, function (err) {
                        return _this.setState({ errors: yupToFormErrors(err), isSubmitting: false });
                    });
                };
                _this.runValidations = function (values$$1) {
                    if (validationSchema) {
                        _this.runValidationSchema(values$$1);
                    }
                    if (validate) {
                        var maybePromisedErrors = validate(values$$1, _this.props);
                        if (isPromise(maybePromisedErrors)) {
                            maybePromisedErrors.then(function () {
                                _this.setState({ errors: {} });
                            }, function (errors) { return _this.setState({ errors: errors, isSubmitting: false }); });
                        }
                        else {
                            _this.setErrors(maybePromisedErrors);
                        }
                    }
                };
                _this.handleChange = function (e) {
                    if (isReactNative) {
                        if (process.env.NODE_ENV !== 'production') {
                            console.error("Warning: Formik's handleChange does not work with React Native. Use setFieldValue and within a callback instead. For more info see https://github.com/jaredpalmer/formikhttps://github.com/jaredpalmer/formik#react-native");
                        }
                        return;
                    }
                    e.persist();
                    var _a = e.target, type = _a.type, name = _a.name, id = _a.id, value = _a.value, checked = _a.checked, outerHTML = _a.outerHTML;
                    var field = name ? name : id;
                    var val = /number|range/.test(type)
                        ? parseFloat(value)
                        : /checkbox/.test(type) ? checked : value;
                    if (!field && process.env.NODE_ENV !== 'production') {
                        console.error("Warning: You forgot to pass an `id` or `name` attribute to your input:\n\n  " + outerHTML + "\n\nFormik cannot determine which value to update. For more info see https://github.com/jaredpalmer/formik#handlechange-e-reactchangeeventany--void\n");
                    }
                    _this.setState(function (prevState) {
                        return (__assign({}, prevState, { values: __assign({}, prevState.values, (_a = {}, _a[field] = val, _a)) }));
                        var _a;
                    });
                    if (validateOnChange) {
                        _this.runValidations(__assign({}, _this.state.values, (_b = {}, _b[field] = value, _b)));
                    }
                    var _b;
                };
                _this.handleChangeValue = function (field, value) {
                    if (process.env.NODE_ENV !== 'production') {
                        console.warn("Warning: Formik's handleChangeValue is deprecated and may be removed in future releases. Use Formik's setFieldValue(field, value) and setFieldTouched(field, isTouched) instead. React will merge the updates under the hood and avoid a double render. For more info see https://github.com/jaredpalmer/formik#setfieldvalue-field-string-value-any--void");
                    }
                    _this.setState(function (prevState) {
                        return (__assign({}, prevState, { values: __assign({}, prevState.values, (_a = {}, _a[field] = value, _a)), touched: __assign({}, prevState.touched, (_b = {}, _b[field] = true, _b)) }));
                        var _a, _b;
                    });
                    _this.runValidationSchema(__assign({}, _this.state.values, (_a = {}, _a[field] = value, _a)));
                    var _a;
                };
                _this.setFieldValue = function (field, value) {
                    _this.setState(function (prevState) {
                        return (__assign({}, prevState, { values: __assign({}, prevState.values, (_a = {}, _a[field] = value, _a)) }));
                        var _a;
                    });
                    if (validateOnChange) {
                        _this.runValidations(__assign({}, _this.state.values, (_a = {}, _a[field] = value, _a)));
                    }
                    var _a;
                };
                _this.handleSubmit = function (e) {
                    e.preventDefault();
                    _this.submitForm();
                };
                _this.submitForm = function () {
                    _this.setState({
                        touched: touchAllFields(_this.state.values),
                        isSubmitting: true,
                    });
                    if (validate) {
                        var maybePromisedErrors = validate(_this.state.values, _this.props) || {};
                        if (isPromise(maybePromisedErrors)) {
                            maybePromisedErrors.then(function () {
                                _this.setState({ errors: {} });
                                _this.executeSubmit();
                            }, function (errors) { return _this.setState({ errors: errors, isSubmitting: false }); });
                            return;
                        }
                        else {
                            var isValid = Object.keys(maybePromisedErrors).length === 0;
                            _this.setState({
                                errors: maybePromisedErrors,
                                isSubmitting: isValid,
                            });
                            if (isValid) {
                                _this.executeSubmit();
                            }
                        }
                    }
                    else if (validationSchema) {
                        _this.runValidationSchema(_this.state.values, _this.executeSubmit);
                    }
                    else {
                        _this.executeSubmit();
                    }
                };
                _this.executeSubmit = function () {
                    var values$$1 = mapValuesToPayload
                        ? mapValuesToPayload(_this.state.values)
                        : _this.state.values;
                    handleSubmit(values$$1, {
                        setStatus: _this.setStatus,
                        setTouched: _this.setTouched,
                        setErrors: _this.setErrors,
                        setError: _this.setError,
                        setValues: _this.setValues,
                        setFieldError: _this.setFieldError,
                        setFieldValue: _this.setFieldValue,
                        setFieldTouched: _this.setFieldTouched,
                        setSubmitting: _this.setSubmitting,
                        resetForm: _this.resetForm,
                        submitForm: _this.submitForm,
                        props: _this.props,
                    });
                };
                _this.handleBlur = function (e) {
                    if (isReactNative) {
                        if (process.env.NODE_ENV !== 'production') {
                            console.error("Warning: Formik's handleBlur does not work with React Native. Use setFieldTouched(field, isTouched) within a callback instead. For more info see https://github.com/jaredpalmer/formik#setfieldtouched-field-string-istouched-boolean--void");
                        }
                        return;
                    }
                    e.persist();
                    var _a = e.target, name = _a.name, id = _a.id;
                    var field = name ? name : id;
                    _this.setState(function (prevState) {
                        return ({
                            touched: __assign({}, prevState.touched, (_a = {}, _a[field] = true, _a)),
                        });
                        var _a;
                    });
                    if (validateOnBlur) {
                        _this.runValidations(_this.state.values);
                    }
                };
                _this.setFieldTouched = function (field, touched) {
                    if (touched === void 0) { touched = true; }
                    _this.setState(function (prevState) {
                        return (__assign({}, prevState, { touched: __assign({}, prevState.touched, (_a = {}, _a[field] = touched, _a)) }));
                        var _a;
                    });
                    if (validateOnBlur) {
                        _this.runValidations(_this.state.values);
                    }
                };
                _this.setFieldError = function (field, message) {
                    _this.setState(function (prevState) {
                        return (__assign({}, prevState, { errors: __assign({}, prevState.errors, (_a = {}, _a[field] = message, _a)) }));
                        var _a;
                    });
                };
                _this.resetForm = function (nextProps) {
                    _this.setState({
                        isSubmitting: false,
                        errors: {},
                        touched: {},
                        error: undefined,
                        status: undefined,
                        values: nextProps
                            ? mapPropsToValues(nextProps)
                            : mapPropsToValues(_this.props),
                    });
                };
                _this.handleReset = function () {
                    _this.setState({
                        isSubmitting: false,
                        errors: {},
                        touched: {},
                        error: undefined,
                        status: undefined,
                        values: mapPropsToValues(_this.props),
                    });
                };
                _this.state = {
                    values: mapPropsToValues(props),
                    errors: {},
                    touched: {},
                    isSubmitting: false,
                };
                if (mapValuesToPayload) {
                    console.warn("Warning: Formik's mapValuesToPayload is deprecated and may be removed in future releases. Move that function to the first line of `handleSubmit` instead.");
                }
                return _this;
            }
            Formik.prototype.render = function () {
                var dirty = values(this.state.touched).filter(Boolean).length > 0;
                return (React.createElement(WrappedComponent, __assign({}, this.props, this.state, { dirty: dirty, isValid: dirty
                        ? this.state.errors &&
                            Object.keys(this.state.errors).length === 0
                        : isInitialValid !== false && isFunction(isInitialValid)
                            ? isInitialValid(this.props)
                            : isInitialValid, setStatus: this.setStatus, setError: this.setError, setFieldError: this.setFieldError, setErrors: this.setErrors, setSubmitting: this.setSubmitting, setTouched: this.setTouched, setFieldTouched: this.setFieldTouched, setValues: this.setValues, setFieldValue: this.setFieldValue, resetForm: this.resetForm, submitForm: this.submitForm, handleReset: this.handleReset, handleSubmit: this.handleSubmit, handleChange: this.handleChange, handleBlur: this.handleBlur, handleChangeValue: this.handleChangeValue })));
            };
            return Formik;
        }(React.Component));
        Formik.displayName = "Formik(" + (displayName ||
            WrappedComponent.displayName ||
            WrappedComponent.name ||
            'Component') + ")";
        Formik.WrappedComponent = WrappedComponent;
        return hoistNonReactStatics(Formik, WrappedComponent);
    };
}
function yupToFormErrors(yupError) {
    var errors = {};
    for (var _i = 0, _a = yupError.inner; _i < _a.length; _i++) {
        var err = _a[_i];
        if (!errors[err.path]) {
            errors[err.path] = err.message;
        }
    }
    return errors;
}
function validateYupSchema(data, schema) {
    var validateData = {};
    for (var k in data) {
        if (data.hasOwnProperty(k)) {
            var key = String(k);
            validateData[key] =
                data[key] !== '' ? data[key] : undefined;
        }
    }
    return schema.validate(validateData, { abortEarly: false });
}
function touchAllFields(fields) {
    var touched = {};
    for (var _i = 0, _a = Object.keys(fields); _i < _a.length; _i++) {
        var k = _a[_i];
        touched[k] = true;
    }
    return touched;
}

exports.Formik = Formik;
exports.yupToFormErrors = yupToFormErrors;
exports.validateYupSchema = validateYupSchema;
exports.touchAllFields = touchAllFields;
//# sourceMappingURL=formik.js.map
